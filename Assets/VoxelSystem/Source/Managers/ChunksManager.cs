using Cysharp.Threading.Tasks; // Used for asynchronous operations like UniTask.Yield and CancellationToken
using System; // Provides basic types and base classes like IDisposable, GC
using System.Collections.Generic; // Provides collection types like Dictionary, Queue, List
using System.Linq; // Provides LINQ extension methods for querying collections
using System.Threading; // Provides CancellationTokenSource and CancellationToken for managing async operations
using Unity.VisualScripting; // Used for AddRange extension method on Dictionary (consider replacing if not essential)
using UnityEditor; // Used for Editor-specific utilities like UnloadUnusedAssetsImmediate (within #if UNITY_EDITOR)
using UnityEngine; // Provides core Unity types like Vector3, Transform, Time
using VoxelSystem.Data.GenerationFlags; // Contains flags like ChunkGenerationFlags
using VoxelSystem.Factory; // Contains ChunkFactory for generating chunk data

// Namespace organizing the voxel system code
namespace VoxelSystem.Managers
{
    /// <summary>
    /// Manages the lifecycle of voxel chunks, including creation, activation, caching, generation, and disposal.
    /// Implements the IChunksManager interface (assumed definition).
    /// </summary>
    public class ChunksManager : IChunksManager, IDisposable // Implement IDisposable for proper cleanup
    {
        // --- Constants ---

        /// <summary>
        /// A string identifier used for performance tracking with AvgCounter.
        /// </summary>
        public const string ChunksManagerLoopString = "ChunksManagerLoop";

        // --- Fields ---

        /// <summary>
        /// Source for creating cancellation tokens to gracefully stop asynchronous operations like ClearChunksAsync.
        /// </summary>
        private readonly CancellationTokenSource _cancellationTokenSource = new();

        /// <summary>
        /// A queue holding reusable Chunk instances to avoid frequent allocations and deallocations.
        /// </summary>
        private readonly Queue<Chunk> _pool = new();

        /// <summary>
        /// A queue holding chunks that are marked for clearing and potential return to the pool.
        /// Processed asynchronously by ClearChunksAsync.
        /// </summary>
        private readonly Queue<Chunk> _chunksToClear = new();

        /// <summary>
        /// Optional parent transform in the Unity hierarchy for organizing chunk GameObjects.
        /// </summary>
        private readonly Transform _parent;

        /// <summary>
        /// Dictionary storing chunks that are currently active and within the render distance.
        /// Key: Chunk position (Vector3). Value: Chunk instance.
        /// </summary>
        private Dictionary<Vector3, Chunk> _active = new();

        /// <summary>
        /// Dictionary storing chunks that were recently active but are now outside the render distance,
        /// kept in memory (cached) for potential quick reactivation.
        /// Key: Chunk position (Vector3). Value: Chunk instance.
        /// </summary>
        private Dictionary<Vector3, Chunk> _cached = new();

        /// <summary>
        /// Dictionary storing chunks that are currently being generated (data, mesh, collider).
        /// Key: Chunk position (Vector3). Value: Chunk instance.
        /// </summary>
        private Dictionary<Vector3, Chunk> _generating = new();

        /// <summary>
        /// Pre-calculated relative positions around the center point that need to be checked for rendering.
        /// Generated by GenerateChunksPositionsCheck using ChunksRenderView.
        /// </summary>
        private Vector3[] _chunksPositionCheck;

        // --- Statistics Fields ---

        /// <summary>
        /// Accumulator for the total number of vertices in active chunk meshes.
        /// </summary>
        private int meshVertices = 0;
        /// <summary>
        /// Accumulator for the total number of indices (triangles * 3) in active chunk meshes.
        /// </summary>
        private int meshIndices = 0;
        /// <summary>
        /// Accumulator for the total number of vertices in active chunk colliders.
        /// </summary>
        private int colliderVertices = 0;
        /// <summary>
        /// Accumulator for the total number of indices (triangles * 3) in active chunk colliders.
        /// </summary>
        private int colliderIndices = 0;

        // --- Properties ---

        /// <summary>
        /// The current center position around which chunks are managed (e.g., player position).
        /// Updated in UpdateChunks.
        /// </summary>
        public Vector3 Center { get; private set; }

        /// <summary>
        /// Private helper property to create a new, default-initialized Chunk instance.
        /// Sets the parent transform and initializes it as inactive.
        /// </summary>
        private Chunk NewChunk
        {
            get
            {
                // Create a new Chunk instance associated with this manager
                Chunk chunk = new(Vector3.zero, this) // Initial position is temporary, will be set by Reuse
                {
                    Parent = _parent, // Assign the parent transform for hierarchy organization
                    Active = false    // Start as inactive
                };
                return chunk;
            }
        }

        // --- Constructor & Initialization ---

        /// <summary>
        /// Initializes a new instance of the ChunksManager.
        /// </summary>
        /// <param name="transform">Optional parent transform for chunk GameObjects.</param>
        public ChunksManager(Transform transform = null)
        {
            _parent = transform; // Store the parent transform

            // Pre-populate the object pool with a number of chunks based on render and cache distances.
            // This helps avoid allocations during runtime when chunks are needed quickly.
            // Calculation assumes a square area; might need adjustment for different world shapes.
            int poolSize = (PlayerSettings.RenderDistance + PlayerSettings.CacheDistance) * (PlayerSettings.RenderDistance + PlayerSettings.CacheDistance);
            for (int i = 0; i < poolSize; i++)
            {
                _pool.Enqueue(NewChunk); // Add newly created, inactive chunks to the pool
            }

            // Pre-calculate the relative positions to check around the center.
            GenerateChunksPositionsCheck();
        }

        /// <summary>
        /// Generates the array of relative chunk positions (_chunksPositionCheck)
        /// based on the render distance. Uses a ChunksRenderView job (assumed definition)
        /// to potentially perform this calculation efficiently.
        /// </summary>
        public void GenerateChunksPositionsCheck()
        {
            // Assuming ChunksRenderView is a struct (possibly an IJob) that calculates positions.
            var job = new ChunksRenderView(Vector3.zero, PlayerSettings.RenderDistance);
            _chunksPositionCheck = job.Complete(); // Execute the job and get the results
            job.Dispose(); // Dispose the job data if necessary (depends on ChunksRenderView implementation)
        }

        // --- Core Update Logic ---

        /// <summary>
        /// Updates the state of chunks based on the new center position.
        /// Moves chunks between active, cached, and generating states, and triggers generation for new chunks.
        /// </summary>
        /// <param name="center">The new center position (e.g., player position).</param>
        public void UpdateChunks(Vector3 center)
        {
            // --- Performance Measurement Start ---
            var updateStartTime = Time.realtimeSinceStartup; // Record start time for performance tracking

            // --- Update Center and State Transition ---
            Center = center; // Update the manager's center position

            // Move all currently active chunks to the cached state.
            // They will be re-evaluated based on the new center position.
            // PERFORMANCE NOTE: AddRange might involve overhead copying dictionary entries.
            // If performance critical, consider iterating _active and moving items individually.
            _cached.AddRange(_active);
            _active.Clear(); // Clear the active dictionary for the new evaluation

            // --- Identify Chunks to Generate ---
            // List to hold data for chunks that need to be generated in this update cycle.
            var chunksToGenerate = new List<GenerationData>();

            // Iterate through the pre-calculated relative positions to check.
            for (int i = 0; i < _chunksPositionCheck.Length; i++)
            {
                // Calculate the absolute world position for the chunk to check.
                // Assuming Y-coordinate is not relevant for chunk key (world is planar or managed vertically elsewhere).
                Vector3 key = new Vector3(_chunksPositionCheck[i].x + Center.x, 0, _chunksPositionCheck[i].z + Center.z);

                // Prepare generation data (position and flags) for this potential chunk.
                var data = new GenerationData()
                {
                    position = key,
                    // Request generation of data, collider, and mesh for chunks within render distance.
                    flags = ChunkGenerationFlags.Data | ChunkGenerationFlags.Collider | ChunkGenerationFlags.Mesh,
                };

                // --- Check Existing Chunk States ---

                // 1. Check if the chunk is already in the cache.
                if (_cached.TryGetValue(key, out Chunk cachedChunk))
                {
                    // Found in cache: Reactivate it.
                    cachedChunk.Active = true; // Mark as logically active
                    cachedChunk.Render = true; // Mark for rendering
                    _active.Add(key, cachedChunk); // Move from cache to active dictionary
                    _cached.Remove(key); // Remove from cache dictionary
                    continue; // Move to the next position
                }

                // 2. Check if the chunk is currently being generated.
                if (_generating.ContainsKey(key)) // Using ContainsKey is slightly faster if value isn't needed here.
                {
                    // Already generating: Do nothing, wait for it to complete.
                    continue; // Move to the next position
                }

                // 3. Not active, not cached, not generating: Needs generation.
                chunksToGenerate.Add(data); // Add its data to the list for batch generation
            }

            // --- Trigger Generation ---
            // If any chunks were identified as needing generation, request it from the ChunkFactory.
            if (chunksToGenerate.Count > 0)
            {
                // Assuming ChunkFactory.Instance handles batch generation requests.
                ChunkFactory.Instance.GenerateChunksData(chunksToGenerate);
                // Note: This likely initiates asynchronous generation jobs.
                // The manager needs to be notified when generation completes (see CompleteGeneratingChunk).
            }

            // --- Performance Measurement End ---
            // Update performance counter with the time taken for this update loop (in milliseconds).
            AvgCounter.UpdateCounter(ChunksManagerLoopString, (Time.realtimeSinceStartup - updateStartTime) * 1000f);

            // --- Initiate Asynchronous Cleanup ---
            // Start the process of clearing chunks that are now outside the cache distance.
            // This runs asynchronously to avoid blocking the main thread.
            ClearChunksAsync(_cancellationTokenSource.Token);
        }


        // --- Chunk State Management ---

        /// <summary>
        /// Retrieves a chunk instance based on its position, searching active, cached, and generating dictionaries.
        /// </summary>
        /// <param name="pos">The world position of the chunk.</param>
        /// <returns>The Chunk instance if found in any state, otherwise null.</returns>
        public Chunk GetChunk(Vector3 pos)
        {
            // Use the null-coalescing operator (??) for concise searching.
            Chunk chunk = GetChunkFromSource(pos, ref _active)      // Check active chunks first
                          ?? GetChunkFromSource(pos, ref _cached)     // Then check cached chunks
                          ?? GetChunkFromSource(pos, ref _generating); // Finally, check generating chunks

            return chunk; // Return the found chunk or null
        }

        /// <summary>
        /// Marks a chunk at the specified position as 'generating'.
        /// If the chunk doesn't exist, it retrieves one from the pool or creates a new one.
        /// </summary>
        /// <param name="pos">The world position of the chunk to mark for generation.</param>
        public void SetChunkToGenerating(Vector3 pos)
        {
            // Try to find the chunk first (it might already exist if generation was requested before).
            Chunk chunk = GetChunk(pos);

            // If the chunk doesn't exist in any state (active, cached, generating)...
            if (chunk == null)
            {
                // Get a reusable chunk from the pool (or create a new one if pool is empty).
                chunk = GetPooledChunk();
                // Initialize the chunk with the target position.
                chunk.Reuse(pos);
                // Mark it as logically active and needing rendering (even if mesh isn't ready yet).
                chunk.Active = true;
                chunk.Render = true;
            }
            // Add the chunk (either existing or newly acquired) to the generating dictionary.
            // Using TryAdd avoids exceptions if the key somehow already exists (though GetChunk should prevent this).
            _generating.TryAdd(pos, chunk);
        }

        /// <summary>
        /// Called when a chunk's generation process (data, mesh, collider) is complete.
        /// Moves the chunk from the 'generating' state to the 'active' state.
        /// </summary>
        /// <param name="pos">The world position of the chunk whose generation is complete.</param>
        public void CompleteGeneratingChunk(Vector3 pos)
        {
            // Try to find the chunk in the generating dictionary.
            if (_generating.TryGetValue(pos, out Chunk chunk))
            {
                // Found: Move it to the active dictionary.
                // Using TryAdd is safer in case of race conditions, though unlikely here.
                _active.TryAdd(pos, chunk);
                // Remove it from the generating dictionary.
                _generating.Remove(pos);
            }
            else
            {
                // Log a warning if a chunk completion is signaled but it's not in the generating list.
                // This might indicate a logic error elsewhere (e.g., double completion signal).
                Debug.LogWarning($"Completed generation for chunk at {pos}, but it was not found in the generating list.");
            }
        }

        /// <summary>
        /// Helper method to safely retrieve a chunk from a specific source dictionary.
        /// </summary>
        /// <param name="pos">The position (key) to look for.</param>
        /// <param name="source">The dictionary to search in.</param>
        /// <returns>The Chunk if found, otherwise null.</returns>
        private Chunk GetChunkFromSource(Vector3 pos, ref Dictionary<Vector3, Chunk> source)
        {
            // Check if the source dictionary is valid.
            if (source == null)
                return null;

            // Use TryGetValue for efficient and safe lookup.
            source.TryGetValue(pos, out Chunk chunk);
            return chunk; // Returns the chunk if found, or null if not.
        }

        // --- Chunk Pooling ---

        /// <summary>
        /// Retrieves a reusable Chunk instance from the pool.
        /// If the pool is empty, it might clear a chunk from the _chunksToClear queue first.
        /// If both are empty, it creates a new Chunk instance.
        /// </summary>
        /// <returns>A reusable or new Chunk instance.</returns>
        private Chunk GetPooledChunk()
        {
            // If the main pool is empty, but there are chunks waiting to be cleared...
            if (_pool.Count == 0 && _chunksToClear.Count > 0)
            {
                // Process one chunk from the clear queue immediately to potentially refill the pool.
                ClearChunkAndEnqueue(_chunksToClear.Dequeue());
            }

            // Now, check the pool again.
            if (_pool.Count > 0)
            {
                // Pool has a chunk, return it.
                return _pool.Dequeue();
            }
            else
            {
                // Pool is still empty (and clear queue was empty or didn't yield a pooled chunk).
                // Create a brand new chunk instance as a fallback.
                // PERFORMANCE NOTE: This indicates the initial pool size might be too small or
                // chunk turnover is very high. Consider increasing the initial pool size.
                Debug.LogWarning("Chunk pool empty, creating a new Chunk instance.");
                return NewChunk;
            }
        }

        /// <summary>
        /// Clears the data of a given chunk (mesh, collider, etc.) and either returns it
        /// to the object pool or disposes of it if the pool is considered full (based on cache size).
        /// </summary>
        /// <param name="chunk">The chunk instance to clear and potentially pool.</param>
        private void ClearChunkAndEnqueue(Chunk chunk)
        {
            // Reset the chunk's internal state (mesh, data, etc.).
            chunk.ClearChunk();

            // Calculate the target pool size based on the cache area (total area minus render area).
            // This logic assumes the pool should hold enough chunks for the cache ring.
            var renderDistSq = PlayerSettings.RenderDistance * PlayerSettings.RenderDistance;
            var totalDistSq = (PlayerSettings.RenderDistance + PlayerSettings.CacheDistance) * (PlayerSettings.RenderDistance + PlayerSettings.CacheDistance);
            var targetPoolSize = totalDistSq - renderDistSq; // Approximate number of chunks in the cache ring

            // If the pool has space according to the target size...
            if (_pool.Count < targetPoolSize)
            {
                // Add the cleared chunk back to the pool for reuse.
                _pool.Enqueue(chunk);
            }
            else
            {
                // Pool is considered full, dispose of the chunk permanently.
                chunk.Dispose();
            }
        }


        // --- Asynchronous Cleanup ---

        /// <summary>
        /// Asynchronously clears chunks that are in the cache (_cached) but outside
        /// the defined cache distance from the Center. Cleared chunks are added to the
        /// _chunksToClear queue, which is then processed iteratively with yields.
        /// </summary>
        /// <param name="cancellationToken">Token to allow cancellation of the process.</param>
        private async void ClearChunksAsync(CancellationToken cancellationToken)
        {
            // --- Identify Chunks to Remove from Cache ---
            // Find keys (positions) in the cached dictionary that are outside the combined
            // render + cache distance from the current center.
            // PERFORMANCE NOTE: LINQ query creates an intermediate list. For very large caches,
            // iterating directly and removing might be slightly more performant, but requires
            // careful handling (e.g., iterating a copy of keys or using a different loop structure).
            List<Vector3> removals = new List<Vector3>();
            int maxDistanceSq = (PlayerSettings.RenderDistance + PlayerSettings.CacheDistance) * (PlayerSettings.RenderDistance + PlayerSettings.CacheDistance);

            // Iterate through the keys of the cached dictionary
            foreach (var key in _cached.Keys)
            {
                // Check if the chunk is outside the maximum allowed distance (using squared distance for efficiency)
                if (!WorldSettings.ChunksInRange(Center, key, maxDistanceSq)) // Assuming ChunksInRange uses squared distance
                {
                    removals.Add(key); // Add the key to the list of chunks to remove
                }
            }


            // --- Process Removals and Update Cache State ---
            // Move identified chunks from the cache to the _chunksToClear queue.
            foreach (var key in removals)
            {
                // Check if the key still exists in cache (important if called concurrently, though less likely with async void)
                if (_cached.TryGetValue(key, out Chunk chunkToClear))
                {
                    _chunksToClear.Enqueue(chunkToClear); // Add the chunk instance to the queue for processing
                    _cached.Remove(key); // Remove the chunk from the cache dictionary
                }
            }

            // Set remaining chunks in the cache dictionary to inactive (logically).
            // Their GameObjects might still be visible until ClearChunk is called.
            foreach (var kvp in _cached) // Iterate through KeyValuePair to access the Chunk directly
            {
                kvp.Value.Active = false; // Mark the chunk as inactive
                // kvp.Value.Render = false; // Optionally also hide renderer immediately if desired
            }

            // --- Process the Clear Queue Asynchronously ---
            // Process the chunks added to the _chunksToClear queue one by one.
            while (_chunksToClear.Count > 0)
            {
                // Check for cancellation request before processing each chunk.
                if (cancellationToken.IsCancellationRequested)
                {
                    Debug.Log("ClearChunksAsync cancelled.");
                    return; // Exit the asynchronous method
                }

                // Dequeue one chunk and process it (clear data, return to pool or dispose).
                ClearChunkAndEnqueue(_chunksToClear.Dequeue());

                // Yield execution back to the engine for one frame.
                // This prevents the cleanup process from blocking the main thread for too long,
                // allowing the game to remain responsive.
                await UniTask.Yield();
            }
        }

        // --- Statistics ---

        /// <summary>
        /// Updates the total mesh vertex and index counts. Called by individual chunks when their mesh updates.
        /// </summary>
        /// <param name="meshVertexChange">The change in vertex count (+/-).</param>
        /// <param name="meshIndexChange">The change in index count (+/-).</param>
        public void UpdateChunkMeshSize(int meshVertexChange, int meshIndexChange)
        {
            meshVertices += meshVertexChange;
            meshIndices += meshIndexChange;
        }

        /// <summary>
        /// Updates the total collider vertex and index counts. Called by individual chunks when their collider updates.
        /// </summary>
        /// <param name="colliderVertexChange">The change in vertex count (+/-).</param>
        /// <param name="colliderIndexChange">The change in index count (+/-).</param>
        public void UpdateChunkColliderSize(int colliderVertexChange, int colliderIndexChange)
        {
            colliderVertices += colliderVertexChange;
            colliderIndices += colliderIndexChange;
        }

        /// <summary>
        /// Gets the current statistics for active chunks and their mesh/collider sizes.
        /// </summary>
        /// <returns>A tuple containing: (active chunk count, total mesh vertices, total mesh indices, total collider vertices, total collider indices).</returns>
        public (int, int, int, int, int) ChunksMeshAndColliderSize()
        {
            // Return the counts stored in the fields.
            return (_active.Count, meshVertices, meshIndices, colliderVertices, colliderIndices);
        }


        // --- Disposal ---

        /// <summary>
        /// Cleans up resources used by the ChunksManager.
        /// Cancels ongoing async operations and disposes all managed chunk instances.
        /// </summary>
        public void Dispose()
        {
            Debug.Log("Disposing ChunksManager...");

            // Signal cancellation to any ongoing asynchronous operations like ClearChunksAsync.
            _cancellationTokenSource.Cancel();
            _cancellationTokenSource.Dispose(); // Dispose the source itself

            // Dispose chunks in the pool.
            while (_pool.Count > 0)
            {
                _pool.Dequeue().Dispose();
            }
            _pool.Clear(); // Ensure the queue is empty

            // Dispose chunks marked for clearing.
            while (_chunksToClear.Count > 0)
            {
                _chunksToClear.Dequeue().Dispose();
            }
            _chunksToClear.Clear();

            // Dispose active chunks.
            foreach (var chunk in _active.Values) // Iterate values directly
            {
                chunk.Dispose();
            }
            _active.Clear();

            // Dispose cached chunks.
            foreach (var chunk in _cached.Values)
            {
                chunk.Dispose();
            }
            _cached.Clear();

            // Dispose chunks currently being generated.
            foreach (var chunk in _generating.Values)
            {
                chunk.Dispose();
            }
            _generating.Clear();

            // Reset statistics
            meshVertices = 0;
            meshIndices = 0;
            colliderVertices = 0;
            colliderIndices = 0;

            // Explicitly clear the position check array if needed
            _chunksPositionCheck = null;


            // --- Editor-Specific Cleanup ---
            // In the Unity Editor, force unloading of unused assets and garbage collection
            // to help clean up memory immediately after disposal. This is generally not
            // recommended for runtime builds due to performance impact.
#if UNITY_EDITOR
            Debug.Log("Running Editor-specific cleanup: UnloadUnusedAssetsImmediate and GC.Collect");
            EditorUtility.UnloadUnusedAssetsImmediate(); // Force unload assets (Editor only)
            GC.Collect(); // Force garbage collection (use sparingly)
#endif

            // Suppress finalization as we've already cleaned up.
            GC.SuppressFinalize(this);
            Debug.Log("ChunksManager disposed.");
        }

        /// <summary>
        /// Finalizer (Destructor) as a safety net.
        /// It's generally better to explicitly call Dispose().
        /// Relying on finalizers can be unpredictable and impact performance.
        /// </summary>
        ~ChunksManager()
        {
            Debug.LogWarning("ChunksManager finalizer called. Dispose() should be called explicitly.");
            // Call Dispose with disposing=false if you had separate logic for finalization,
            // but here we just call the main Dispose method.
            Dispose();
        }
    }
}
